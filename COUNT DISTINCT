SELECT
  (    count(DISTINCT user_id) 
  -(    count(DISTINCT user_id) FILTER(        WHERE
          action = 'cancel_order'      )
    )
  ) AS users_count
FROM
  user_actions


Если после агрегирующей функции указать ключевое слово FILTER и поместить в скобках некоторое условие [condition] после WHERE, то агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным. В общем виде эта конструкция выглядит так:
SELECT agg_function(column) FILTER (WHERE [condition])
FROM table
Пример:
SELECT AVG(column_1) FILTER (WHERE column_2 > 100)
FROM table
Это очень похоже на обычную фильтрацию с агрегацией, которую мы рассматривали в предыдущих задачах, только в данном случае условие на отбор записей указывается сразу в блоке SELECT. Преимущество такой записи в том, что она позволяет проводить некоторые расчёты без необходимости писать отдельные запросы с блоком WHERE для получения промежуточных результатов. 
Рассмотрим следующий пример.
В нашем случае довольно понятно, как посчитать общее количество пользователей, также вроде бы понятно, как посчитать количество пользователей, которые хотя бы раз отменяли заказ — достаточно просто указать нужное условие в операторе WHERE. Но как в рамках одного запроса посчитать тех, кто никогда не отменял свой заказ? Поскольку объединять несколько запросов вместе мы пока не умеем, на помощь нам может прийти агрегатное выражение.
________________________________________
Задание:
Посчитайте, сколько пользователей никогда не отменяли свой заказ. Для этого из общего числа всех уникальных пользователей отнимите число уникальных пользователей, которые хотя бы раз отменяли заказ. Подумайте, какое условие необходимо указать в FILTER, чтобы получить корректный результат. Полученный столбец назовите users_count.
Поле в результирующе таблице: users_count
Когда решите задачу, подумайте, смогли бы мы сейчас с ней справиться без агрегатных выражений.
