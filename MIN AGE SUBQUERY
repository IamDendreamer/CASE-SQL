SELECT  AGE(mintime,  birth_date)::varchar  as min_age
    from
      couriers, (select max(time)::DATE as mintime from courier_actions) as subquery1   ///вложенный запрос 
where  sex = 'male'
order by min_age
limit 1

Получается, что в одном из прошлых уроков мы неправильно считали возраст курьеров.
Действительно, в качестве первой даты в функции AGE() мы использовали текущую дату, а не последнюю дату в наших данных.
Давайте исправим это досадное недоразумение, ведь теперь у нас для этого есть все необходимые знания.
Задание:
С помощью функции AGE() и агрегирующей функции снова рассчитайте возраст самого молодого курьера мужского пола в таблице couriers,
но в этот раз в качестве первой даты используйте последнюю дату из таблицы courier_actions. Чтобы получилась именно дата,
перед применением функции AGE() переведите посчитанную последнюю дату в формат DATE, как мы делали в этом задании.
Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип VARCHAR. Полученную колонку со значением возраста назовите min_age.
Поле в результирующей таблице: min_age
Пояснение:
В этой задаче результат подзапроса выступает в качестве аргумента функции. Чтобы весь запрос выглядел компактнее,
для приведения данных к другому типу можно использовать формат записи с двумя двоеточиями — ::.
Также обратите внимание, что для получения необходимого результата мы обращаемся к разным таблицам в рамках одного общего запроса — так делать тоже можно. 
